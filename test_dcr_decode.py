from __future__ import print_function
import argparse
import os
import sys
import traceback

import numpy

from dcr_decode_astropy import processDcrData, eprint

# These are not unit tests! This is a regression test suite that is intended
# to ensure that the "new decoding code" results in the exact answers as the
# original sparrow code.


def scanRegressionTest(projPath,
                       receiver,
                       scanNum,
                       polarization,
                       resultsDict):
    """Given a project path, receiver, polarization, as well as
    a "results file" generated by sparrow, use the former to generate
    a "decoded DCR data table" and compare it to the results file."""

    result = processDcrData(
        projPath=projPath,
        scanNum=scanNum,
        receiver=receiver,
        polarization=polarization
    )

    for key, value in resultsDict.items():
        beam, polarization, frequency, phase = key
        # Phase is stored as this weird string, so compare
        # to get an int out as CAL column expects
        sigRefState, calState = [i.strip() for i in phase.split('/')]
        if sigRefState == 'Signal':
            sigRefState = 0
        elif sigRefState == 'Reference':
            sigRefState = 1
        else:
            raise ValueError("Unsupported SIGREF value '{}' "
                             "derived from phase '{}'"
                             .format(sigRefState, phase))

        if calState == 'Cal':
            calState = 1
        elif calState == 'No Cal':
            calState = 0
        else:
            raise ValueError("Unsupported calState value '{}' "
                             "derived from phase '{}'"
                             .format(calState, phase))

        mask = (
            (result['FEED'] == int(beam)) &
            (numpy.char.rstrip(result['POLARIZE']) == polarization) &
            (result['CENTER_SKY'] == float(frequency)) &
            (result['SIGREF'] == sigRefState) &
            (result['CAL'] == calState)
        )

        if not numpy.all(result[mask]['DATA'].data == value):
            raise ValueError("Results do not match!",
                             {
                                'oldData': [value[0], value[-1]],
                                'newData': result[mask]['DATA'],
                                'allNewData': result['DATA']
                             })


def testProcessDcrData(sparrow_results_dir, results_manifest):
    sparrow_results = os.listdir(sparrow_results_dir)
    numResults = len(sparrow_results)
    numProcessed = 0
    projectStep = 1
    scanStep = 10
    scansToProcess = numResults / (projectStep * scanStep)

    print("There are {0} total scan result files. We will be processing every "
          "{1} scan of every {2} project. So, we expect to process a total "
          "of {3} scan results"
          .format(numResults, scanStep, projectStep, scansToProcess))

    for receiver, projInfos in results_manifest.items():
        # Looks like there was a bug in the data collection and this
        # list is not completely flat. Easy enough, we'll just flatten
        # it
        projInfosFlat = []
        for item in projInfos:
            if type(item) == list:
                projInfosFlat.extend(item)
            else:
                projInfosFlat.append(item)

        print("Processing every {}th project out of {} total for receiver {}"
              .format(projectStep, len(projInfosFlat), receiver))

        for projInfo in projInfosFlat[::projectStep]:
            try:
                projName, projParentPath, scans = projInfo
            except ValueError as e:
                eprint(traceback.format_exc(e))
                eprint("Invalid projInfo: {}".format(projInfo))

            projPath = os.path.join(projParentPath, projName)

            print("Processing every {}th scan out of {} total from project {}"
                  .format(scanStep, len(scans), projName))
            for scanNum in scans[::scanStep]:
                sparrow_result_name = (
                    "{proj}:{scan}:{rcvr}".format(proj=projName,
                                                  scan=scanNum,
                                                  rcvr=receiver)
                )
                sparrow_results_file = os.path.join(sparrow_results_dir,
                                                    sparrow_result_name)

                try:
                    with open(sparrow_results_file) as f:
                        resultsDict = eval(f.read())
                except IOError as e:
                    eprint(e)
                    eprint("Could not find sparrow results file {}"
                          .format(sparrow_results_file))
                    break

                print("projPath: {}\n"
                      "receiver: {}\n"
                      "scanNum: {}"
                      .format(projPath, receiver, scanNum))

                print("BEGIN Processing sparrow result file {}/{}"
                      .format(numProcessed, scansToProcess))
                try:
                    scanRegressionTest(
                        projPath=projPath,
                        receiver=receiver,
                        scanNum=scanNum,
                        # NOTE: Not actually needed; value doesn't matter
                        polarization="X",
                        resultsDict=resultsDict
                    )
                except Exception as e:
                    eprint(traceback.format_exc(e))
                    eprint("Something went wrong for project {}"
                          .format(projName))
                else:
                    print("Results for sparrow file '{}' MATCH results "
                          "for new method!"
                          .format(sparrow_results_file))

                numProcessed += 1
                print()
                print()


def parseArgs():
    """Parse CLI arguments and return them"""

    parser = argparse.ArgumentParser()
    parser.add_argument("pathToTestData",
                        help="The path to the Sparrow data to run this "
                             "regression test against",
                        default="/home/scratch/pmargani/allDcrData")
    parser.add_argument("pathToResultsManifest",
                        help="The path to the sparrow results manifiest "
                             "file. This is a text file containing "
                             "a dictionary that indicates where to find "
                             "each project on disk",
                        default="./rcvrDCRscans.txt")

    return parser.parse_args()


if __name__ == '__main__':
    args = parseArgs()

    # TODO: This is fragile! We need to control the method of creating this
    # data alongside this script or it will be worthless in the future
    with open(args.pathToResultsManifest) as f:
        results_manifest = eval(f.read())

    testProcessDcrData(args.pathToTestData, results_manifest)
