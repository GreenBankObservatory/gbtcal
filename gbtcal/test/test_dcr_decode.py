from __future__ import print_function
import ast
import argparse
import os
import traceback

import numpy

from dcr_table import DcrTable
from gbtcal.decode import getFitsForScan

# These are not unit tests! This is a regression test suite that is intended
# to ensure that the "new decoding code" results in the exact answers as the
# original sparrow code.

def initLogging():
    """Initialize the logger for this module and return it"""

    logger = logging.getLogger(__name__)
    logger.setLevel(logging.DEBUG)
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    # console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    return logger


logger = initLogging()


def scanRegressionTest(projPath,
                       receiver,
                       scanNum,
                       polarization,
                       resultsDict):
    """Given a project path, receiver, polarization, as well as
    a "results file" generated by sparrow, use the former to generate
    a "decoded DCR data table" and compare it to the results file."""
    # TODO: I probably broke this!
    fitsForScan = getFitsForScan(projPath, scanNum)
    table = DcrTable.read(fitsForScan['DCR'], fitsForScan['IF'])

    for key, value in resultsDict.items():
        beam, polarization, frequency, phase = key
        # Phase is stored as this weird string, so compare
        # to get an int out as CAL column expects
        sigRefState, calState = [i.strip() for i in phase.split('/')]
        if sigRefState == 'Signal':
            sigRefState = 0
        elif sigRefState == 'Reference':
            sigRefState = 1
        else:
            raise ValueError("Unsupported SIGREF value '{}' "
                             "derived from phase '{}'"
                             .format(sigRefState, phase))

        if calState == 'Cal':
            calState = 1
        elif calState == 'No Cal':
            calState = 0
        else:
            raise ValueError("Unsupported calState value '{}' "
                             "derived from phase '{}'"
                             .format(calState, phase))

        mask = (
            (table['FEED'] == int(beam)) &
            (numpy.char.rstrip(table['POLARIZE']) == polarization) &
            (table['CENTER_SKY'] == float(frequency)) &
            (table['SIGREF'] == sigRefState) &
            (table['CAL'] == calState)
        )

        if not numpy.all(table[mask]['DATA'].data == value):
            raise ValueError("Results do not match!",
                             {
                                 'oldData': [value[0], value[-1]],
                                 'newData': table[mask]['DATA'],
                                 'allNewData': table['DATA']
                             })


def testProcessDcrData(sparrow_results_dir, results_manifest):
    sparrow_results = os.listdir(sparrow_results_dir)
    numResults = len(sparrow_results)
    numProcessed = 0
    projectStep = 1
    scanStep = 10
    scansToProcess = numResults / (projectStep * scanStep)

    print("There are {0} total scan result files. We will be processing every "
          "{1} scan of every {2} project. So, we expect to process a total "
          "of {3} scan results"
          .format(numResults, scanStep, projectStep, scansToProcess))

    for receiver, projInfos in results_manifest.items():
        # Looks like there was a bug in the data collection and this
        # list is not completely flat. Easy enough, we'll just flatten
        # it
        projInfosFlat = []
        for item in projInfos:
            if type(item) == list:
                projInfosFlat.extend(item)
            else:
                projInfosFlat.append(item)

        print("Processing every {}th project out of {} total for receiver {}"
              .format(projectStep, len(projInfosFlat), receiver))

        for projInfo in projInfosFlat[::projectStep]:
            try:
                projName, projParentPath, scans = projInfo
            except ValueError as e:
                logger.error(traceback.format_exc(e))
                logger.error("Invalid projInfo: {}".format(projInfo))

            projPath = os.path.join(projParentPath, projName)

            print("Processing every {}th scan out of {} total from project {}"
                  .format(scanStep, len(scans), projName))
            for scanNum in scans[::scanStep]:
                sparrow_result_name = (
                    "{proj}:{scan}:{rcvr}".format(proj=projName,
                                                  scan=scanNum,
                                                  rcvr=receiver)
                )
                sparrow_results_file = os.path.join(sparrow_results_dir,
                                                    sparrow_result_name)

                try:
                    with open(sparrow_results_file) as f:
                        resultsDict = ast.literal_eval(f.read())
                except IOError as e:
                    logger.error(e)
                    logger.error("Could not find sparrow results file {}"
                           .format(sparrow_results_file))
                    break

                print("projPath: {}\n"
                      "receiver: {}\n"
                      "scanNum: {}"
                      .format(projPath, receiver, scanNum))

                print("BEGIN Processing sparrow result file {}/{}"
                      .format(numProcessed, scansToProcess))
                try:
                    scanRegressionTest(
                        projPath=projPath,
                        receiver=receiver,
                        scanNum=scanNum,
                        # NOTE: Not actually needed; value doesn't matter
                        polarization="X",
                        resultsDict=resultsDict
                    )
                except Exception as e:
                    logger.error(traceback.format_exc(e))
                    logger.error("Something went wrong for project {}"
                           .format(projName))
                else:
                    print("Results for sparrow file '{}' MATCH results "
                          "for new method!"
                          .format(sparrow_results_file))

                numProcessed += 1
                print()
                print()


def parseArgs():
    """Parse CLI arguments and return them"""

    parser = argparse.ArgumentParser()
    parser.add_argument("pathToTestData",
                        help="The path to the Sparrow data to run this "
                             "regression test against",
                        default="/home/scratch/pmargani/allDcrData")
    parser.add_argument("pathToResultsManifest",
                        help="The path to the sparrow results manifiest "
                             "file. This is a text file containing "
                             "a dictionary that indicates where to find "
                             "each project on disk",
                        default="./rcvrDCRscans.txt")

    return parser.parse_args()


if __name__ == '__main__':
    args = parseArgs()

    # TODO: This is fragile! We need to control the method of creating this
    # data alongside this script or it will be worthless in the future
    with open(args.pathToResultsManifest) as f:
        results_manifest = ast.literal_eval(f.read())

    testProcessDcrData(args.pathToTestData, results_manifest)
